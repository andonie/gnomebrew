"""
This file manages Gnomebrew's Game World consisting of different planes of existence as well as a tiered system
of Regions, Structures, and Maps.

The content of planes is generated by Gnomebrew dynamically but determined fully by location coordinates.
"""
import math
from typing import List, Tuple

from gnomebrew.game.objects.generation import GeneratedGameObject, generation_type, Generator, Environment, \
    GenerationRule, apply_processing_rule
from gnomebrew.game.objects.people import Person
from gnomebrew.game.objects.static_object import StaticGameObject, load_on_startup
from gnomebrew.game.testing import application_test
from gnomebrew.game.user import User, get_resolver
from logging import debug


class WorldLocation:
    """
    Abstractly describes a location in the game world from a small room to an entire plane.
    """

    EMPTY_GENERATION_RULE = GenerationRule({
        'game_id': 'gen.special.empty',
        'env_rules': {},
        'gen_attr': {}
    })

    # Lookup table for the generation of sublocations
    _level_gen_class_lookup = {
        0: None,  # 'world.' level does not generate as planes are static
        1: 'Prevalent Regions',
        2: 'Prevalent Structures',
        3: 'Prevalent Chunks',
    }

    _level_class_name_lookup = {
        0: None,
        1: 'Plane',
        2: 'Region',
        3: 'Structure',
        4: 'Chunk'
    }

    def __init__(self, address: str):
        """
        Base Initialization of a location.
        :param address: The full address of this location in the game world.
        """
        super().__init__()
        self.address = address
        self.environment = Environment()

    def __str__(self):
        """
        Creates a nice string out of this game world for debugging purposes.
        :return:    String representation of this location.
        """
        return f"<Location at {self.address}: {self.get_location_name()} ({self.get_location_type_name()} {self.get_location_class_name()})\n" \
               f"{str(self.environment)}>"

    def set_environment(self, environment: Environment):
        """
        Resets this location's environment entirely.
        :param environment:     The new environment to set as this location's whole environment
        """
        self.environment = environment

    def generate_people(self, num_people: int) -> List[Person]:
        """
        Generates some people that come from this particular location.
        This is **nondeterministic** in the sense of Generation. Even identical environment and location generate
        different people every time.
        :param num_people:  Amount of people to generate.
        :return:            A list of generated people that would be situated in this location.
        """
        generator = Generator(Generator.true_random_generator_seed(), self.environment.create_copy())
        return [generator.generate('Person') for i in range(num_people)]

    def generate_sub_location(self, location_sub_address: str) -> 'WorldLocation':
        """
        Generates a sub-location for this world-location.
        :param location_sub_address:    Address for this location. Must be 4-digit hex string, e.g. `eF25`
        :return:                    The sub-location for this environment at the given address.
        """
        assert self.get_location_level() < 4  # No smaller than chunks!
        # Instantiate the appropriate generator for the sublocation (= seed)
        gen = Generator(location_sub_address, self.environment.create_copy())

        # Define Rule Class to be used
        generation_class_name = gen.choose(
            gen.get_env_var(WorldLocation._level_gen_class_lookup[self.get_location_level()]))
        ruleset: GenerationRule = GenerationRule.get_rule_by_name(generation_class_name,
                                                                  default=WorldLocation.EMPTY_GENERATION_RULE)

        if ruleset.get_static_value('game_id') == 'gen.special.empty':
            debug(f"No rule found for {generation_class_name}. Will do no generation.")
            # Do set the name of this location based on
            gen.update_env_var(f"{WorldLocation._level_class_name_lookup[self.get_location_level() + 1]} Name",
                               generation_class_name)

        # Incorporate the selected region's environment rules into the generator's environment
        gen.incorporate_env_rules(ruleset.get_static_value('env_rules'))

        # Go through this rule's attributes to generate and process the rules
        attributes_to_generate: dict = ruleset.get_static_value('gen_attr')
        for attribute in attributes_to_generate:
            result = gen.process_generation_rule(attributes_to_generate[attribute])
            gen.update_env_var(attribute, result)

        # Define the location type in the environment as well
        gen.update_env_var(f"{WorldLocation._level_class_name_lookup[self.get_location_level() + 1]} Type",
                           generation_class_name)

        return GeneratedLocation(f"{self.address}.{location_sub_address}",
                                 gen.get_environment(),
                                 list(attributes_to_generate.keys()))

    def get_location_level(self) -> int:
        """
        Returns the level of this location.
        :return:    The level of this location:
                    Chunk = 4
                    Structure = 3
                    Region = 2
                    Plane = 1
                    [World = 0]
        """
        return len(self.address.split('.')) - 1

    def get_plane(self) -> str:
        """
        Returns the ID of the location's plane of existence.
        :return:    A string representing the location's plane, e.g. 'feywild'
        """
        return self.address.split('.')[1]

    def get_location_name(self) -> str:
        """
        Returns the name of this location
        :return:    Name of this location
        """
        return self.environment.get(f"{WorldLocation._level_class_name_lookup[self.get_location_level()]} Name")

    def get_location_type_name(self) -> str:
        """
        Returns the name of this location type.
        :return:    name of this location type, e.g. 'Taiga', 'City', etc.
        """
        return self.environment.get(f"{WorldLocation._level_class_name_lookup[self.get_location_level()]} Type")

    def get_location_class_name(self) -> str:
        """
        Returns the class name of this location.
        :return:    Class name of this location, e.g. 'Plane', 'Chunk'
        """
        return WorldLocation._level_class_name_lookup[self.get_location_level()]

    def get_two_dimensional_coordinates(self) -> Tuple[List[int], List[int]]:
        """
        Returns a tuple listing planar X/Y coordinates of this location.
        :return:    (x, y) where x and y are respective lists of coordinates of all relevant location levels.
                    The coordinates are listed in the order: region-structure-chunk. Coordinates are only set for
                    the level in which this particular location is defined (i.e. a region will not provide
                    contain chunk-level coordinates)
        """
        x_coordinates, y_coordinates = [], []
        for subaddress in self.address.split('.')[2:]:
            x_coordinates.append(int(subaddress[:1], 16))
            y_coordinates.append(int(subaddress[2:], 16))
        return x_coordinates, y_coordinates

    def distances_to(self, other: 'WorldLocation') -> List[float]:
        """
        Calculates the distances between this location and another world location on all relevant layers.
        :param other:   Another world location.
        :return:        The shortest distance in between both locations (using Pythagorean Theorem). The distance
                        is calculated individually for each location layer. `[0, 0, 30]` means that the locations
                        share the same region and structure and have a distance of 30 chunk-units.
        """
        if self.get_plane() != other.get_plane():
            raise Exception(f"{str(self)} and {str(other)} are on different planes; "
                            f"they don't have a defined location distance.")
        # Get coordinate lists from both locations
        x1, y1 = self.get_two_dimensional_coordinates()
        x2, y2 = other.get_two_dimensional_coordinates()
        result = []
        for i in range(min(len(x1), len(x2))):
            result.append(math.sqrt((x1[i] - x2[i]) ** 2 + (y1[i] - y2[i]) ** 2))

        return result


@load_on_startup('planes')
class Plane(StaticGameObject, WorldLocation):
    """
    Describes a plane of existence defined in the game's database. Contains the base data to generate sub location
    levels from.
    """

    def __init__(self, db_data):
        StaticGameObject.__init__(self, db_data)
        WorldLocation.__init__(self, self.get_id())

        # Make DB Data Available to Plane Environment
        for env_var in self._data['env_rules']:
            self.environment.set_env_var(env_var, self._data['env_rules'][env_var])


class GeneratedLocation(GeneratedGameObject, WorldLocation):
    """
    Describes a generated location in the game of any scale. Includes regions, structures, and chunks.
    """

    def __init__(self, full_address, environment: Environment, core_descriptors: List[str]):
        """
        Creates a generated location.
        :param full_address:        Fully qualified address of this location, e.g. `'world.feywild.AABB.CCDD'`
        :param environment:         The environment describing this location.
        :param core_descriptors:    The core descriptors of this environment as a list of environment variable names,
                                    e.g. `['Region Name', 'Danger Level']`
        """
        GeneratedGameObject.__init__(self)
        WorldLocation.__init__(self, full_address)
        self.core_descriptors = core_descriptors
        self.set_environment(environment)

    def add_core_descriptor(self, env_var_name: str):
        """
        Adds an environment variable to the list of core descriptors. Core descriptors are environment variables of this
        location that have an elevated role in the UI.
        :param env_var_name:    A varname to be added to the core descriptors.
        """
        self.core_descriptors.append(env_var_name)


@get_resolver('world')
def get_world_location(game_id: str, user: User, **kwargs) -> WorldLocation:
    """
    Returns the corresponding world location
    :param game_id:     ID. Different location tiers are possible,
                        e.g. 'world.gaia.3EAC.BBD7', 'world.hell'
    :param user:        a user
    :param kwargs:      ?
    :return:            The location corresponding to the given ID
    """
    splits = game_id.split('.')
    # Get the plane first
    location: Plane = StaticGameObject.from_id('.'.join(splits[:2]))
    for addr in splits[2:]:
        location = location.generate_sub_location(addr)
    return location


# Environment Update Rules

@Environment.update_rule('Temperature')
def temperature_update(gen: Generator, old, new):
    if isinstance(new, dict):
        # Complex command: Resolve as generation rule
        mid_sum = apply_processing_rule(gen, old, new)
    else:
        mid_sum = old + new
    return mid_sum + gen.rand_normal(deviation=gen.get_env_var('Temperature Fluctuation'))


def numeric_dict_merge(d1: dict, d2: dict) -> dict:
    """
    Merges two dictionaries numerically, meaning that the values of keys appearing in both dictionaries will be added
    together.
    :param d1:  A dict
    :param d2:  Another dict
    :return:    The resulting, new merged dict. Contains the keys and values of both dicts, but values of keys appearing
                in both dicts are added together.
    """
    intersect = set(d1.keys()) & set(d2.keys())
    # Directly insert whatever value from other we don't have set in self
    result = dict()
    result.update({k: v for k, v in d1.items() if k not in intersect})
    result.update({k: v for k, v in d2.items() if k not in intersect})
    for key in intersect:
        result[key] = d1[key] + d2[key]
    return result


@Environment.update_rule('Prevalent People')
def prev_people_update(gen: Generator, old: dict, new: dict):
    return numeric_dict_merge(old, new)


@Environment.update_rule('Prevalent Regions')
def prev_regions_update(gen: Generator, old: dict, new: dict):
    return numeric_dict_merge(old, new)


@Environment.update_rule('Prevalent Structures')
def prev_structures_update(gen: Generator, old: dict, new: dict):
    return numeric_dict_merge(old, new)

# Application Testing
